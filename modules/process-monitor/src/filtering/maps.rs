use bpf_common::{
    aya::{self, maps::MapError},
    Pid,
};

use super::config::Rule;

/// This map assigns to every running process a PolicyDecision:
/// - Are we interested in events generated by this process?
/// - Are we interested in events generated by its children?
pub(crate) struct InterestMap(pub(crate) aya::maps::HashMap<aya::maps::MapRefMut, i32, u8>);

impl InterestMap {
    /// Try to load the map from eBPF
    pub(crate) fn load(bpf: &mut aya::Bpf) -> Result<Self, MapError> {
        let map = aya::maps::HashMap::try_from(bpf.map_mut("map_interest")?)?;
        Ok(Self(map))
    }

    /// Clear the map
    pub(crate) fn clear(&mut self) -> Result<(), MapError> {
        let old_processes: Result<Vec<i32>, _> = self.0.keys().collect();
        old_processes?
            .iter()
            .try_for_each(|pid| self.0.remove(pid))?;
        Ok(())
    }

    /// Update the interest map by setting the policy decision of a given process
    pub(crate) fn set(&mut self, pid: Pid, policy_result: PolicyDecision) -> Result<(), MapError> {
        self.0.insert(pid.as_raw(), policy_result.as_raw(), 0)?;
        Ok(())
    }
}

#[derive(Clone, Copy)]
pub(crate) struct PolicyDecision {
    pub(crate) interesting: bool,
    pub(crate) children_interesting: bool,
}

impl Default for PolicyDecision {
    fn default() -> Self {
        Self {
            interesting: true,
            children_interesting: true,
        }
    }
}

impl PolicyDecision {
    /// Convert the `PolicyDecision` to a bit field
    pub(crate) fn as_raw(&self) -> u8 {
        match (self.children_interesting, self.interesting) {
            (false, false) => 0,
            (false, true) => 1,
            (true, false) => 2,
            (true, true) => 3,
        }
    }
}

/// A RuleMap contains the target/whitelist images and weather or not the rule
/// should affect its children.
/// Whitelist and target list have the same fields, so we use a single struct for both.
pub(crate) struct RuleMap(aya::maps::HashMap<aya::maps::MapRefMut, Image, u8>);

#[derive(Clone, Copy)]
struct Image([u8; MAX_IMAGE_LEN]);
const MAX_IMAGE_LEN: usize = 100;
// We must explicitly mark Image as a plain old data which can be safely memcopied by aya.
unsafe impl bpf_common::aya::Pod for Image {}

impl RuleMap {
    /// Try to load the whitelist map
    pub(crate) fn whitelist(bpf: &mut aya::Bpf) -> Result<Self, MapError> {
        let map = aya::maps::HashMap::try_from(bpf.map_mut("whitelist")?)?;
        Ok(Self(map))
    }

    /// Try to load the target map
    pub(crate) fn target(bpf: &mut aya::Bpf) -> Result<Self, MapError> {
        let map = aya::maps::HashMap::try_from(bpf.map_mut("target")?)?;
        Ok(Self(map))
    }

    /// Clear the map
    pub(crate) fn clear(&mut self) -> Result<(), MapError> {
        let old_processes: Result<Vec<_>, _> = self.0.keys().collect();
        old_processes?
            .iter()
            .try_for_each(|image| self.0.remove(image))?;
        Ok(())
    }

    /// Fill the map with a list of rules
    pub(crate) fn install(&mut self, rules: &Vec<Rule>) -> Result<(), MapError> {
        for rule in rules {
            if !rule.image.is_ascii() {
                // RETURN ERROR
                log::error!("Unvalid filtering rule: {}", rule.image);
                continue;
            }
            let mut src: Vec<u8> = rule.image.bytes().collect();
            if src.len() >= MAX_IMAGE_LEN {
                log::warn!("Image name is too long {:?}", rule);
            }
            src.resize(MAX_IMAGE_LEN, 0);
            let mut image: Image = Image([0; MAX_IMAGE_LEN]);
            image.0.clone_from_slice(&src[..]);
            let value: u8 = if rule.with_children { 1 } else { 0 };
            self.0.insert(image, value, 0)?;
        }
        Ok(())
    }
}
